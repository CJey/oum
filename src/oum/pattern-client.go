package main

import (
	"bytes"
	"database/sql"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"db"
	"github.com/cjey/slog"
	"utils"
)

func fetchDevType(lines []string, platform string) string {
	def := "dev-type tun"
	find := utils.FetchConfKey(lines, "dev-type", def)
	fs := strings.Fields(find)
	if len(fs) < 2 || strings.ToLower(fs[1]) != "tap" {
		if platform == "linux" {
			find = "dev oum\n" +
				"dev-type tun"
		} else {
			find = "dev tun\n" +
				"#dev <use a name you like> # Linux [only]\n" +
				"dev-type tun"
		}
	} else {
		if platform == "linux" {
			find = "dev oum\n" +
				"dev-type tap"
		} else {
			find = "dev tap\n" +
				"#dev <use a name you like>\n" +
				"dev-type tap"
		}
	}
	return find + "\n"
}

func fetchProto(lines []string) string {
	def := "proto tcp-server"
	find := utils.FetchConfKey(lines, "proto", def)
	fs := strings.Fields(find)
	if len(fs) < 2 {
		find = "proto tcp-client\n\n" +
			"#proto udp"
	} else {
		pt := strings.ToLower(fs[1])
		switch pt {
		case "tcp-server":
			find = "proto tcp-client\n\n" +
				"#proto udp"
		case "udp":
			find = "#proto tcp-client\n\n" +
				"proto udp"
		default:
			find = "proto tcp-client\n\n" +
				"#proto udp"
		}
	}
	return find + "\n"
}

func fetchCA(lines []string) string {
	calines := utils.FetchConfBlock(lines, "<ca>", "</ca>")
	if len(calines) == 0 {
		slog.Emerg("no ca found")
		os.Exit(1)
	}
	return strings.Join(calines, "\n") + "\n"
}

func fetchCipher(lines []string) string {
	def := "cipher AES-128-CBC"
	find := utils.FetchConfKey(lines, "cipher", def)
	fs := strings.Fields(find)
	if len(fs) < 2 {
		find = def
	}
	return find + "\n"
}

func fetchAuth(lines []string) string {
	def := "auth SHA1"
	find := utils.FetchConfKey(lines, "auth", def)
	fs := strings.Fields(find)
	if len(fs) < 2 {
		find = def
	}
	return find + "\n"
}

func fetchRemote(lines []string, quick bool) string {
	//var remote string
	remote := utils.PrimaryIP()
	for {
		if quick {
			break
		}
		fmt.Printf("Remote Server Host(%s): ", remote)
		line := utils.Readline(remote)
		// TODO: check?
		remote = line
		break
	}

	port := "1194"
	find := utils.FetchConfKey(lines, "port", "")
	fs := strings.Fields(find)
	if len(fs) >= 2 {
		var p uint16
		_, err := fmt.Sscan(fs[1], &p)
		if err == nil {
			port = fs[1]
		}
	}

	for {
		if quick {
			break
		}

		fmt.Printf("Remote Server Port(%s): ", port)
		line := utils.Readline(port)
		var p uint16
		_, err := fmt.Sscan(line, &p)
		if err != nil {
			fmt.Printf("%s %s\n", errpre, err.Error())
			continue
		}
		port = line
		break
	}

	return fmt.Sprintf("remote %s %s\n", remote, port)
}

func showPatternDev(dev, outpath string) {
	DB := db.Get()

	var host, port, srvpath string
	err := DB.QueryRow(`
        select remote, port, conffile from ovpn
        where dev=?
    `, dev).Scan(&host, &port, &srvpath)
	if err != nil {
		if err == sql.ErrNoRows {
			slog.Emergf("dev[%s] not found, please configure talbe: ovpn first", dev)
		} else {
			slog.Emerg(err.Error())
		}
		os.Exit(1)
	}
	remote := fmt.Sprintf("remote %s %s\n", host, port)

	lines, err := utils.StripConf(srvpath)
	if err != nil {
		slog.Emerg(err.Error())
		os.Exit(1)
	}
	res := fetchPatternClient(lines, "", remote)
	if outpath == "-" {
		fmt.Printf("\n>>>> copy all blow to file with suffix .conf(linux) or .ovpn(other) <<<<\n\n")
		fmt.Printf("%s", res)
	} else {
		err = ioutil.WriteFile(outpath, res, 0664)
		if err != nil {
			slog.Emerg(err.Error())
			os.Exit(1)
		}
	}
}

func showPatternFrom(srvpath, outpath string, quick bool) {
	lines, err := utils.StripConf(srvpath)
	if err != nil {
		slog.Emerg(err.Error())
		os.Exit(1)
	}
	res := fetchPatternClient(lines, "", fetchRemote(lines, quick))
	if outpath == "-" {
		fmt.Printf("\n>>>> copy all blow to file with suffix .conf(linux) or .ovpn(other) <<<<\n\n")
		fmt.Printf("%s", res)
	} else {
		err = ioutil.WriteFile(outpath, res, 0664)
		if err != nil {
			slog.Emerg(err.Error())
			os.Exit(1)
		}
	}
}

func fetchPatternClient(lines []string, platform, remote string) []byte {
	devtype := fetchDevType(lines, platform)
	proto := fetchProto(lines)
	certs := fetchCA(lines)
	cipher := fetchCipher(lines)
	auth := fetchAuth(lines)

	var buf bytes.Buffer

	buf.WriteString("# openvpn conf - client\n")
	buf.WriteString("# auto generated by oum\n\n")
	buf.WriteString(remote)
	buf.WriteString("# ----------------\n\n")
	buf.WriteString("# Linux [only], and [must] uncomment\n")
	if platform == "linux" {
		buf.WriteString("script-security 2\n")
		buf.WriteString("up   /etc/openvpn/update-resolv-conf\n")
		buf.WriteString("down /etc/openvpn/update-resolv-conf\n")
	} else {
		buf.WriteString("#script-security 2\n")
		buf.WriteString("#up   /etc/openvpn/update-resolv-conf\n")
		buf.WriteString("#down /etc/openvpn/update-resolv-conf\n")
	}
	buf.WriteString("# ----------------\n\n")
	buf.WriteString("auth-user-pass\n\n")
	buf.WriteString("# also, you can specify pass file path instead\n")
	buf.WriteString("# file format: <username>(first line), <password>(second line)\n")
	buf.WriteString("#auth-user-pass <pass file path>\n")
	buf.WriteString("# ----------------\n\n")
	buf.WriteString(devtype)
	buf.WriteString("# ----------------\n\n")
	buf.WriteString(proto)
	buf.WriteString("# ----------------\n\n")
	buf.WriteString(cipher)
	buf.WriteString(auth)
	buf.WriteString("# ----------------\n\n")
	buf.WriteString("verb 3\n")
	buf.WriteString("reneg-sec 0\n")
	buf.WriteString("topology subnet\n")
	buf.WriteString("route-metric 1000\n")
	buf.WriteString("nobind\n")
	buf.WriteString("pull\n")
	buf.WriteString("tls-client\n")
	buf.WriteString("tun-mtu 1400\n")
	buf.WriteString("persist-key\n")
	buf.WriteString("persist-tun\n")
	buf.WriteString("# ----------------\n\n")
	buf.WriteString(certs)

	return buf.Bytes()
}
